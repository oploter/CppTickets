

## Лекция 4
- Если deg(v) + deg(u) >= n - 1 (для всех пар несмежных вершин) -> граф связный
- Маршрут нечетной длины имеет нечетный простой цикл
- Ребро -- мост <=> оне не принадлежит ни одному циклу в графе
- Пусть вершина v инцидента **мосту** e, тогда v -- точка сочленения <=> deg(v) >= 2 (Док-во через мост <=> не лежит в цикле)
- Если v -- точка сочленения, тогда $\forall$ w, u из разных компонент связности -> в исходном графе существует единнственный путь, проходящий через v
- v -- точка сочленения <=> $\exists$ такие u, w, что v $\in$ любому u-w пути
- Операции с графами -- объединение, пересечение, несвязное объединение, симметрическая разность
- Дерево **(опр. 1)**, лес
- В любом дереве есть хотя бы 2 листа
- У дерева на n вершинах n - 1 ребро
- Связный граф на n вершинах с n - 1 ребром является деревом **(опр. 2)**
- Следствия:
  1) В любом связном графе на n вершинах хотя бы n - 1 ребро
  2) У любого связного графа существует остовное поддерево (остовный подграф, являющийся деревом)
- Алгоритмы поиска остовного поддерева
  1) Пока есть цикл -> удали ребро (сложно)
  2) DFS O(V + E) - рекурсивно / с помощью очереди
     ```c++
     def dfs(int x, int p){
       parent[x] = p; // parent -- остовное поддерево графа
     }
     ```
- Связный граф -- дерево ТиТТ все ребра -- мосты **(опр. 3)**
- Связный граф -- дерево ТиТТ для любых 2 вершин существует единственный путь, соединящий их **(опр. 4)**
- Ацикличный граф G -- дерево ТиТТ добавив любое ребро не из E(G) появится один цикл, содержащий новое ребро **(опр. 5)**
- Операция персадки ребра
  : G - свзяный граф; T, T' - остовные поддеревья G. Тогда для любого ребра e из T, найдется ребро e' из T' :
  T \ {e} U {e'} - остовное поддерево G
- Алгоритм Краскала док-во [ссылка](http://people.qc.cuny.edu/faculty/christopher.hanusa/courses/634sp12/Documents/KruskalProof.pdf). Индукция по количеству отличающихся ребер между получившимся деревом и MST

  ## Лекция 5
Корневое дерево
: Выделение вершины и назвали его корнем
- Корневой лес, уровень вершина, высота дерева
- Отец, сын, предок, потомок
- ЧУМ (КЧУМ) -- (X, *), причем
  1) x * x
  2) x * y, y * z -> x * z
  3) x * y, y * x -> x = y
- * -- "является делителем". Могут быть несравнимые элементы (3, 4) 
- * -- "<="
- Порядок в дереве корневом: x * y -> x -- предок y
- Цепь в ЧУМ / Антицепь в ЧУМ 
- Теорема Дилуорса: Для любого КЧУМ верно, что существует множество цепей, количество которых равно максимальной лдине антицепи + Теорема Мирского
- Наибольшая длина цепи в корневом дереве
- M-арное дерево
- Св-ва DFS
  1) Нормальное поддерево
  2) **Но** высоты вершин не равно кратчайшим путям
- Алгорритм посторения оствного поддерева T, сохраняющий кратчайшие расстояния (BFS)
- Теорема: BFS построит поддерево, так как добавление в стек вершины (кроме) эквивалентно проведению ребра между этой вершиной и той, которая добавила эту. Добавлено вершин n - 1 -> ребер n - 1 и связность сохранилась -> T - поддерево
  # Эйлеровы циклы / Графы
- Эйлеров путь, эйлеров цикл - реберно простой
- Существование путей и цкилов в графах
- Эйлеров граф, полуэйлеровый граф
- Необходимое и достаточное условие существования эйлерова цикла (связный и степень каждой вершины четная)
- Доастаточно - идем, пока можем, но в итоге можем не обойти все ребра. Останутся компоненты связности, в которых степень каждой вершины четна
- Необходимо. Если начали из вершины A, вошли в вершину B. Так как должны закончить в A -> должны выйти из B -> Для каждой вершины != A входящему ребру соответствует исходящее. A - тоже четно
- Четный граф -- любая вершина имеет четную степень
- Теорема: Связный граф эйлеров четный ТиТТ эйлеров
- В графе существует эйлеров путь ТиТТ все за исключением 2 вершин четны
- Эйлеров цикл есть в орграфе ТиТТ indeg(x) = indeg(y)
- Если A -- матрица смежность -> a_(ij)^k = (A^k)_(ij) - количество маршрутов из i -> j длиной k
- 
[Наследование C++](https://www.startertutorials.com/blog/inheritance-in-c.html)
# Алгоритмы
## Прима [сслыка](https://neerc.ifmo.ru/wiki/index.php?title=Алгоритм_Прима)
### Графы [ссылка](https://iq.opengenus.org/list-of-graph-algorithms/)
### Поиск всех путей S -> D [leetcode](https://leetcode.com/problems/all-paths-from-source-to-target/submissions/)

### Задача: найти площадь объединения прямоугольников
#### O(n^3).
Отсортируем массив координат x и y - получим матрицу. Кахждый элемент матрицы (кроме первой строки и столбца) соответствует какому-то прямоугольнику, который либо точно покрыт, либо точно не покрыт. Нужно расставить в матрице 1, где покрыты. Пройти еще раз по матрице и проссумировать площади.
Реализация:
- Для каждого прямоугольника проходимся по всей матрице и проверяем каждую клетку. **O(4n^3)**
- Бинпоиском найти индексы границ прямоугольника и пометить только эти клетки. **O(sum_i(S_i)+2nlog(2n))**
- Обратные ссылки. После сортировки массивов пройтись еще раз и запомнить для каждого прямоугольника индексы его начала и конца.**O(sum_i(S_i))**
#### O(n^2) / O(n^2 log(n))
Будем идти слева направо. Для каждого отрезка x - соотвествует набор y-ов. Отсортируем y-и -- задача о нахождении объединения отрезков -- O(nlog(n)) * n
- Можно y отсортировать сразу. Проходить по всем y, но выбирать те, которые соответствуют текущей полоске.

